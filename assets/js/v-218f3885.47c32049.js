"use strict";(self.webpackChunknode_docs=self.webpackChunknode_docs||[]).push([[6610],{6977:(e,n,s)=>{s.r(n),s.d(n,{data:()=>a});const a=JSON.parse('{"key":"v-218f3885","path":"/node-lessons/lesson2.html","title":"2.一个最简单的 express 应用","lang":"zh-CN","frontmatter":{"order":2,"description":"目标 建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 http://localhost:3000/ 时，输出 Hello World。 挑战 访问 http://localhost:3000/ 时，输出 你好，世界。 知识点 1. 包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。 2. 框架 express 。学习新建 ...","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/node-docs/node-docs/node-lessons/lesson2.html"}],["meta",{"property":"og:site_name","content":"node-docs"}],["meta",{"property":"og:title","content":"2.一个最简单的 express 应用"}],["meta",{"property":"og:description","content":"目标 建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 http://localhost:3000/ 时，输出 Hello World。 挑战 访问 http://localhost:3000/ 时，输出 你好，世界。 知识点 1. 包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。 2. 框架 express 。学习新建 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-03-26T15:48:25.000Z"}],["meta",{"property":"article:modified_time","content":"2022-03-26T15:48:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"2.一个最简单的 express 应用\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-03-26T15:48:25.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":2,"title":"挑战","slug":"挑战","link":"#挑战","children":[]},{"level":2,"title":"知识点","slug":"知识点","link":"#知识点","children":[]},{"level":2,"title":"课程内容","slug":"课程内容","link":"#课程内容","children":[{"level":3,"title":"包管理器 npm","slug":"包管理器-npm","link":"#包管理器-npm","children":[]},{"level":3,"title":"框架 Express","slug":"框架-express","link":"#框架-express","children":[]}]},{"level":2,"title":"补充知识","slug":"补充知识","link":"#补充知识","children":[{"level":3,"title":"端口","slug":"端口","link":"#端口","children":[]},{"level":3,"title":"URL","slug":"url","link":"#url","children":[]},{"level":3,"title":"尾声","slug":"尾声","link":"#尾声","children":[]}]}],"git":{"createdTime":1648309705000,"updatedTime":1648309705000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":4.7,"words":1411},"filePathRelative":"node-lessons/lesson2.md","localizedDate":"2022年3月26日","autoDesc":true,"excerpt":""}')},8843:(e,n,s)=>{s.r(n),s.d(n,{default:()=>j});var a=s(6808);const t=(0,a.uE)('<h1 id="_2-一个最简单的-express-应用" tabindex="-1"><a class="header-anchor" href="#_2-一个最简单的-express-应用" aria-hidden="true">#</a> 2.一个最简单的 express 应用</h1><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h2><p>建立一个 lesson1 项目，在其中编写代码。当在浏览器中访问 <code>http://localhost:3000/</code> 时，输出 <code>Hello World</code>。</p><h2 id="挑战" tabindex="-1"><a class="header-anchor" href="#挑战" aria-hidden="true">#</a> 挑战</h2><p>访问 <code>http://localhost:3000/</code> 时，输出 <code>你好，世界</code>。</p><h2 id="知识点" tabindex="-1"><a class="header-anchor" href="#知识点" aria-hidden="true">#</a> 知识点</h2><ol><li>包管理器 npm 。使用 npm 安装包，并自动安装所需依赖。</li><li>框架 express 。学习新建 express 实例，并定义 routes ，产生输出。</li></ol><h2 id="课程内容" tabindex="-1"><a class="header-anchor" href="#课程内容" aria-hidden="true">#</a> 课程内容</h2><p>按照惯例，我们来个 helloworld 入门。</p><h3 id="包管理器-npm" tabindex="-1"><a class="header-anchor" href="#包管理器-npm" aria-hidden="true">#</a> 包管理器 npm</h3><p>npm 可以自动管理包的依赖. 只需要安装你想要的包, 不必考虑这个包的依赖包.</p><p>在 PHP 中, 包管理使用的 <code>Composer</code>, python 中，包管理使用 <code>easy_install</code> 或者 <code>pip</code>，ruby 中我们使用 <code>gem</code>。而在 Node.js 中，对应就是 <code>npm</code>，npm 是 <code>Node.js Package Manager</code> 的意思。</p><h3 id="框架-express" tabindex="-1"><a class="header-anchor" href="#框架-express" aria-hidden="true">#</a> 框架 Express</h3><p>express 是 Node.js 应用最广泛的 web 框架，现在是 4.x 版本，它非常薄。跟 Rails 比起来，完全两个极端。</p>',14),l={href:"http://expressjs.com/",target:"_blank",rel:"noopener noreferrer"},o=(0,a.uE)('<p>首先我们需要得到一个 express。</p><p>不同于 ruby 的 gem 装在全局，Node.js 的依赖是以项目为单位管理的，直接就安装在项目的 <code>node_modules</code> 目录下，而且每个依赖都可以有指定版本的其他依赖，这些依赖像一棵树一样。根据我自己的使用经验来说，npm 的体验在 pip 和 gem 之上。</p><p>OK，新建一个文件夹叫 lesson1 的，进去里面安装 express</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>$ mkdir lesson1 &amp;&amp; cd lesson1\n# 这里没有从官方 npm 安装，而是使用了大淘宝的 npm 镜像\n$ npm install express --registry=https://registry.npmmirror.com\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>安装完成后，我们的 lesson1 目录下应该会出现一个 <code>node_modules</code> 文件夹，<code>ls</code> 看看</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ls</span> node_modules\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>里面如果出现 express 文件夹则说明安装成功。</p><p>或者 npm命令提供更清晰直观的显示:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">npm</span> list\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>我们继续应用程序的编写。</p><p>新建一个 app.js 文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">touch</span> app.js\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>copy 进去这些代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 这句的意思就是引入 `express` 模块，并将它赋予 `express` 这个变量等待使用。</span>\n<span class="token keyword">import</span> express <span class="token keyword">from</span> <span class="token string">&#39;express&#39;</span>\n<span class="token comment">// 调用 express 实例，它是一个函数，不带参数调用时，会返回一个 express 实例，将这个变量赋予 app 变量。</span>\n<span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// app 本身有很多方法，其中包括最常用的 get、post、put/patch、delete，在这里我们调用其中的 get 方法，为我们的 `/` 路径指定一个 handler 函数。</span>\n<span class="token comment">// 这个 handler 函数会接收 req 和 res 两个对象，他们分别是请求的 request 和 response。</span>\n<span class="token comment">// request 中包含了浏览器传来的各种信息，比如 query 啊，body 啊，headers 啊之类的，都可以通过 req 对象访问到。</span>\n<span class="token comment">// res 对象，我们一般不从里面取信息，而是通过它来定制我们向浏览器输出的信息，比如 header 信息，比如想要向浏览器输出的内容。这里我们调用了它的 #send 方法，向浏览器输出一个字符串。</span>\napp<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&#39;/&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">&#39;Hello World&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 定义好我们 app 的行为之后，让它监听本地的 3000 端口。这里的第二个函数是个回调函数，会在 listen 动作成功后执行，我们这里执行了一个命令行输出操作，告诉我们监听动作已完成。</span>\napp<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;app is listening at port 3000&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行</p><p><code>$ node app.js</code></p><p>这时候我们的 app 就跑起来了，终端中会输出 <code>app is listening at port 3000</code>。这时我们打开浏览器，访问 <code>http://localhost:3000/</code>，会出现 <code>Hello World</code>。如果没有出现的话，肯定是上述哪一步弄错了，自己调试一下。</p><h2 id="补充知识" tabindex="-1"><a class="header-anchor" href="#补充知识" aria-hidden="true">#</a> 补充知识</h2><p>在这个例子中，node代码监听了3000端口，用户通过访问<code>http://localhost:3000/</code> 得到了内容，为什么呢？</p><h3 id="端口" tabindex="-1"><a class="header-anchor" href="#端口" aria-hidden="true">#</a> 端口</h3>',20),p=(0,a._)("code",null,"通过端口来区分出同一电脑内不同应用或者进程，从而实现一条物理网线(通过分组交换技术-比如internet)同时链接多个程序",-1),r={href:"http://en.wikipedia.org/wiki/Port_(computer_networking)",target:"_blank",rel:"noopener noreferrer"},i=(0,a._)("p",null,"端口号是一个 16位的 uint, 所以其范围为 1 to 65535 (对TCP来说, port 0 被保留，不能被使用. 对于UDP来说, source端的端口号是可选的， 为0时表示无端口).",-1),c=(0,a._)("p",null,[(0,a._)("code",null,"app.listen(3000)"),(0,a.Uk)("，进程就被打标，电脑接收到的3000端口的网络消息就会被发送给我们启动的这个进程")],-1),d=(0,a._)("h3",{id:"url",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#url","aria-hidden":"true"},"#"),(0,a.Uk)(" URL")],-1),u={href:"http://www.ietf.org/rfc/rfc1738.txt",target:"_blank",rel:"noopener noreferrer"},h=(0,a._)("code",null,"<scheme>:<scheme-specific-part>",-1),m=(0,a._)("code",null,"http",-1),k=(0,a._)("code",null,"https",-1),v=(0,a._)("code",null,"ftp",-1),g=(0,a._)("code",null,"ed2k",-1),b=(0,a._)("code",null,"thunder",-1),x=(0,a.uE)('<p>通常我们熟悉的url定义成这个样子</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>用过ftp的估计能体会这么长的，网页上很少带auth信息，所以就精简成这样:</p><div class="language-txt line-numbers-mode" data-ext="txt"><pre class="language-txt"><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;url-path&gt;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在上面的例子中, scheme=http, host=localhost, port=3000, url-path=/, 再联想对照一下浏览器端<code>window.location</code>对象。 著名的<code>localhost</code>，你可以在电脑的hosts文件上找到</p>',5),f={href:"http://en.wikipedia.org/wiki/URI_scheme",target:"_blank",rel:"noopener noreferrer"},_=(0,a._)("code",null,'URI schemes are frequently and incorrectly referred to as "protocols", or specifically as URI protocols or URL protocols, since most were originally designed to be used with a particular protocol, and often have the same name',-1),y=(0,a._)("h3",{id:"尾声",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#尾声","aria-hidden":"true"},"#"),(0,a.Uk)(" 尾声")],-1),U=(0,a._)("p",null,[(0,a.Uk)("在了解完端口和url之后，再去看例子代码，相信应该好理解很多。 有必要的话，还可以在解剖一下express的use逻辑，对峙"),(0,a._)("code",null,"http.createServer"),(0,a.Uk)("，相信还有火花，😃")],-1),w={},j=(0,s(8580).Z)(w,[["render",function(e,n){const s=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)("div",null,[t,(0,a._)("p",null,[(0,a.Uk)("express 的官网是 "),(0,a._)("a",l,[(0,a.Uk)("http://expressjs.com/"),(0,a.Wm)(s)]),(0,a.Uk)(" ，我常常上去看它的 API。")]),o,(0,a._)("p",null,[(0,a.Uk)("端口的作用："),p,(0,a._)("a",r,[(0,a.Uk)("Port_(computer_networking)"),(0,a.Wm)(s)])]),i,c,d,(0,a._)("p",null,[(0,a._)("a",u,[(0,a.Uk)("RFC1738"),(0,a.Wm)(s)]),(0,a.Uk)(" 定义的url格式笼统版本"),h,(0,a.Uk)("， scheme有我们很熟悉的"),m,(0,a.Uk)("、"),k,(0,a.Uk)("、"),v,(0,a.Uk)("，以及著名的"),g,(0,a.Uk)("，"),b,(0,a.Uk)("。")]),x,(0,a._)("p",null,[(0,a._)("a",f,[(0,a.Uk)("在这篇文章中提到"),(0,a.Wm)(s)]),(0,a.Uk)("： "),_,(0,a.Uk)("，比较认同这个观点，尤其是今天移动设备的时代里， android和ios的开发中大量使用uri作为跨app通讯通道，把scheme理解为协议略狭隘了。")]),y,U])}]])},8580:(e,n)=>{n.Z=(e,n)=>{const s=e.__vccOpts||e;for(const[e,a]of n)s[e]=a;return s}}}]);