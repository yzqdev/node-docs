"use strict";(self.webpackChunknode_docs=self.webpackChunknode_docs||[]).push([[3724],{6830:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e=JSON.parse('{"key":"v-29ff825a","path":"/node-lessons/lesson19.html","title":"19.何为 connect 中间件","lang":"zh-CN","frontmatter":{"order":19,"description":"目标 1. 理解中间件的概念 1. 了解 Connect 的实现 课程内容 1. 原生 httpServer 遇到的问题 1. 中间件思想 1. Connect 实现 1. Express 简介 这是从 httpServer 到 Express 的升级过程。 HTTP Nodejs 的经典 httpServer 代码 里面的函数 requestHand...","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/node-docs/node-docs/node-lessons/lesson19.html"}],["meta",{"property":"og:site_name","content":"node-docs"}],["meta",{"property":"og:title","content":"19.何为 connect 中间件"}],["meta",{"property":"og:description","content":"目标 1. 理解中间件的概念 1. 了解 Connect 的实现 课程内容 1. 原生 httpServer 遇到的问题 1. 中间件思想 1. Connect 实现 1. Express 简介 这是从 httpServer 到 Express 的升级过程。 HTTP Nodejs 的经典 httpServer 代码 里面的函数 requestHand..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-03-26T15:48:25.000Z"}],["meta",{"property":"article:modified_time","content":"2022-03-26T15:48:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"19.何为 connect 中间件\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-03-26T15:48:25.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"目标","slug":"目标","link":"#目标","children":[]},{"level":2,"title":"课程内容","slug":"课程内容","link":"#课程内容","children":[]},{"level":2,"title":"HTTP","slug":"http","link":"#http","children":[]},{"level":2,"title":"createServer()","slug":"createserver","link":"#createserver","children":[]},{"level":2,"title":"app.use(route, fn)","slug":"app-use-route-fn","link":"#app-use-route-fn","children":[]},{"level":2,"title":"app.handle(req, res, out)","slug":"app-handle-req-res-out","link":"#app-handle-req-res-out","children":[]},{"level":2,"title":"call(handle, route, err, req, res, next)","slug":"call-handle-route-err-req-res-next","link":"#call-handle-route-err-req-res-next","children":[]},{"level":2,"title":"listen","slug":"listen","link":"#listen","children":[]},{"level":2,"title":"图解Connect","slug":"图解connect","link":"#图解connect","children":[]},{"level":2,"title":"Connect的subapp特性","slug":"connect的subapp特性","link":"#connect的subapp特性","children":[]},{"level":2,"title":"Router","slug":"router","link":"#router","children":[]},{"level":2,"title":"Request","slug":"request","link":"#request","children":[]},{"level":2,"title":"Response","slug":"response","link":"#response","children":[]},{"level":2,"title":"Application","slug":"application","link":"#application","children":[]},{"level":2,"title":"Express小结","slug":"express小结","link":"#express小结","children":[]}],"git":{"createdTime":1648309705000,"updatedTime":1648309705000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":1}]},"readingTime":{"minutes":11.61,"words":3483},"filePathRelative":"node-lessons/lesson19.md","localizedDate":"2022年3月26日","autoDesc":true,"excerpt":""}')},216:(n,s,a)=>{a.r(s),a.d(s,{default:()=>D});var e=a(6808);const t=(0,e.uE)('<h1 id="_19-何为-connect-中间件" tabindex="-1"><a class="header-anchor" href="#_19-何为-connect-中间件" aria-hidden="true">#</a> 19.何为 connect 中间件</h1><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h2><ol><li>理解中间件的概念</li><li>了解 Connect 的实现</li></ol><h2 id="课程内容" tabindex="-1"><a class="header-anchor" href="#课程内容" aria-hidden="true">#</a> 课程内容</h2><ol><li>原生 httpServer 遇到的问题</li><li>中间件思想</li><li>Connect 实现</li><li>Express 简介</li></ol><p>这是从 httpServer 到 Express 的升级过程。</p><h2 id="http" tabindex="-1"><a class="header-anchor" href="#http" aria-hidden="true">#</a> HTTP</h2><p>Nodejs 的经典 httpServer 代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;http&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span>requestHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">requestHandler</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;hello visitor!&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nserver<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>里面的函数 <code>requestHandler</code> 就是所有http请求的响应函数，即所有的请求都经过这个函数的处理，是所有请求的入口函数。</p><p>通过 requestHandler 函数我们能写一些简单的 http 逻辑，比如上面的例子，所有请求都返回 <code>hello visitor!</code>。</p><p>然而，我们的业务逻辑不可能这么简单。例如：需要实现一个接口，要做的是当请求过来时，先判断来源的请求是否包含请求体，然后判断请求体中的id是不是在数据库中存在，最后若存在则返回true，不存在则返回false。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>1. 检测请求中请求体是否存在，若存在则解析请求体；\n1. 查看请求体中的id是否存在，若存在则去数据库查询；\n1. 根据数据库结果返回约定的值；\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们首先想到的，抽离函数，每个逻辑一个函数，简单好实现低耦合好维护。</p><p>实现代码:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">parseBody</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//根据http协议从req中解析body</span>\n  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> body<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">checkIdInDatabase</span><span class="token punctuation">(</span><span class="token parameter">body<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">//根据body.id在Database中检测，返回结果</span>\n  <span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> dbResult<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">returnResult</span><span class="token punctuation">(</span><span class="token parameter">dbResult<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>dbResult <span class="token operator">&amp;&amp;</span> dbResult<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">requestHandler</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">parseBody</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> body</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">checkIdInDatabase</span><span class="token punctuation">(</span>body<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> dbResult</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token function">returnResult</span><span class="token punctuation">(</span>dbResult<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的解决方案解决了包含三个步骤的业务问题，出现了3个 <code>});</code> 还有3个 <code>err</code> 需要处理，上面的写法可以得达到预期效果。</p><p>然而，业务逻辑越来越复杂，会出发展成30个回调逻辑，那么就出现了30个 <code>});</code> 及30个 <code>err</code>异常。更严重的是，到时候写代码根本看不清自己写的逻辑在30层中的哪一层，极其容易出现 <strong>多次返回</strong> 或返回地方不对等问题，这就是 <strong>回调金字塔</strong> 问题了。</p><p>大多数同学应该能想到解决回调金字塔的办法，朴灵的《深入浅出Node.js》里讲到的三种方法。下面列举了这三种方法加上ES6新增的Generator，共四种解决办法。</p>',19),p={href:"https://github.com/JacksonTian/eventproxy",target:"_blank",rel:"noopener noreferrer"},o={href:"https://github.com/petkaantonov/bluebird",target:"_blank",rel:"noopener noreferrer"},c={href:"https://github.com/caolan/async",target:"_blank",rel:"noopener noreferrer"},l={href:"http://es6.ruanyifeng.com/#docs/generator",target:"_blank",rel:"noopener noreferrer"},i=(0,e._)("p",null,[(0,e.Uk)("理论上，这四种都能解决回调金字塔问题。而Connect和Express用的是 "),(0,e._)("code",null,"类似异步流程控制的思想"),(0,e.Uk)(" 。")],-1),r=(0,e._)("a",{name:"next"},null,-1),u={href:"https://github.com/alsotang/node-lessons/tree/master/lesson5",target:"_blank",rel:"noopener noreferrer"},d=(0,e._)("strong",null,"顺序执行",-1),k=(0,e._)("p",null,"callback是控制顺序执行的关键，funlist里的函数每当调用callback会执行下一个funlist里的函数",-1),v=(0,e._)("p",null,[(0,e.Uk)("我们动手实现一个类似的链式调用，其中 "),(0,e._)("code",null,"funlist"),(0,e.Uk)(" 更名为 "),(0,e._)("code",null,"middlewares"),(0,e.Uk)("、"),(0,e._)("code",null,"callback"),(0,e.Uk)(" 更名为 "),(0,e._)("code",null,"next"),(0,e.Uk)("，码如下：")],-1),m=(0,e._)("p",null,[(0,e._)("a",{name:"middlewares",comment:"middlewares锚点"})],-1),b=(0,e.uE)('<div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> middlewares <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token keyword">function</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">parseBody</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> body</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      req<span class="token punctuation">.</span>body <span class="token operator">=</span> body<span class="token punctuation">;</span>\n      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">fun2</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">checkIdInDatabase</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>body<span class="token punctuation">.</span>id<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> rows</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      res<span class="token punctuation">.</span>dbResult <span class="token operator">=</span> rows<span class="token punctuation">;</span>\n      <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token function">fun3</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span>dbResult <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span>dbResult<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;true&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;false&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">]</span>\n\n<span class="token keyword">function</span> <span class="token function">requestHandler</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>\n\n  <span class="token comment">//由middlewares链式调用</span>\n  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&#39;error:&#39;</span><span class="token punctuation">,</span> err<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>middlewares<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      middlewares<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">//触发第一个middleware</span>\n  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面用middlewares+next完成了业务逻辑的 <code>链式调用</code>，而middlewares里的每个函数，都是一个 <code>中间件</code>。</p><p>整体思路是：</p><ol><li>将所有 <code>处理逻辑函数(中间件)</code> 存储在一个list中；</li><li>请求到达时 <code>循环调用</code> list中的 <code>处理逻辑函数(中间件)</code>；</li></ol>',4),h={id:"connect的实现",tabindex:"-1"},g=(0,e._)("a",{class:"header-anchor",href:"#connect的实现","aria-hidden":"true"},"#",-1),f={href:"https://github.com/senchalabs/connect",target:"_blank",rel:"noopener noreferrer"},x=(0,e.uE)('<p>Connect的思想跟上面阐述的思想基本一样，先将处理逻辑存起来，然后循环调用。</p><p>Connect中主要有五个函数 PS: Connect的核心代码是200+行，建议对照<a href="https://github.com/senchalabs/connect/blob/master/index.js" target="_blank">源码</a>看下面的函数介绍。</p><table><thead><tr><th>函数名</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><td>createServer</td><td style="text-align:center;">包装httpServer形成app</td></tr><tr><td>listen</td><td style="text-align:center;">监听端口函数</td></tr><tr><td>use</td><td style="text-align:center;">向middlewares里面放入业务逻辑</td></tr><tr><td>handle</td><td style="text-align:center;">上一章的requestHandler函数增强版</td></tr><tr><td>call</td><td style="text-align:center;">业务逻辑的真正执行者</td></tr></tbody></table><h2 id="createserver" tabindex="-1"><a class="header-anchor" href="#createserver" aria-hidden="true">#</a> createServer()</h2><p><strong>输入</strong>:</p><p>无</p><p><strong>执行过程</strong>:</p>',7),y=(0,e._)("li",null,"app是一个函数对象(包含handle方法)",-1),w={href:"https://github.com/jaredhanson/utils-merge",target:"_blank",rel:"noopener noreferrer"},_=(0,e._)("li",null,[(0,e.Uk)("app有route属性(路由)、和stack属性(用于存储中间件，类似上面的"),(0,e._)("a",{href:"#middlewares"},"middlewares"),(0,e.Uk)(")")],-1),q=(0,e.uE)('<p><strong>输出</strong>:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>       app is function(req, res, next) {...};\n        |\n    +---+---+\n    |  has  |\n  route   stack\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="app-use-route-fn" tabindex="-1"><a class="header-anchor" href="#app-use-route-fn" aria-hidden="true">#</a> app.use(route, fn)</h2><p>作用是向stack中添加 <code>逻辑处理函数</code> (中间件)。</p><p><strong>输入</strong>:</p><ol><li>route 可省略，默认&#39;/&#39;</li><li>fn 具体的业务处理逻辑</li></ol><p><strong>tips:</strong></p><p>上面的fn表示处理逻辑，它可以是</p>',8),j=(0,e._)("li",null,[(0,e.Uk)("一个普通的 "),(0,e._)("code",null,"function(req,res[,next]){}"),(0,e.Uk)("；")],-1),U={href:"https://lodejs.org/api/http.html#http_class_http_server",target:"_blank",rel:"noopener noreferrer"},C=(0,e._)("li",null,[(0,e.Uk)("另一个connect的app对象("),(0,e._)("strong",null,"sub app特性"),(0,e.Uk)(")；")],-1),E=(0,e.uE)('<p>由于它们的本质都是 <code>处理逻辑</code>，都可以用一个 <code>function(req,res,next){}</code>将它们概括起来，Connect把他们都转化为这个函数，然后把它们存起来。</p><p>如何将这三种分别转换为 function(req, res, next) {}的形式呢？</p><ol><li>不用转换；</li><li>httpServer的定义是“对事件&#39;request&#39;后handler的对象”，我们可以从httpServer.listeners(&#39;request&#39;)中得到这个函数；</li><li>另一个connect对象，而connect()返回的app就是function(req, res, out) {}；</li></ol><p><strong>执行过程</strong>:</p><ol><li>将三种<code>处理逻辑</code>统一转换为<code>function(req,res,next){}</code>的形式表示。</li><li>把这个<code>处理逻辑</code>与route一起，放入<code>stack</code>中(存储处理逻辑，route用来匹配路由)</li></ol><p>核心代码片段</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//route是路由路径，handle是一个`function(req, res, next) {...}`形式的业务逻辑</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">route</span><span class="token operator">:</span> path<span class="token punctuation">,</span> <span class="token literal-property property">handle</span><span class="token operator">:</span> handle <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>返回</strong>:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//返回自己，可以完成链式调用</span>\n<span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>总结:</strong>:</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\napp<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">&#39;/api&#39;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>等价于</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\napp<span class="token punctuation">.</span>stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token literal-property property">route</span><span class="token operator">:</span> <span class="token string">&#39;/api&#39;</span><span class="token punctuation">,</span> <span class="token function-variable function">handle</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>最后，app.stack里 <strong>顺序存储</strong> 了所有的 <strong>逻辑处理函数</strong> (中间件)。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>app<span class="token punctuation">.</span>stack <span class="token operator">=</span> <span class="token punctuation">[</span>function1<span class="token punctuation">,</span> function2<span class="token punctuation">,</span> function3<span class="token punctuation">,</span> <span class="token operator">...</span> function30<span class="token punctuation">]</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="app-handle-req-res-out" tabindex="-1"><a class="header-anchor" href="#app-handle-req-res-out" aria-hidden="true">#</a> app.handle(req, res, out)</h2><p>这个函数就是请求到达时，负责 <code>顺序调用</code> 我们存储在stack中的 <code>逻辑处理函数</code> (中间件)函数，类似上一章的requestHandler。</p><p><strong>输入:</strong></p><ol><li>req是Nodejs本身的可读流，不做过多介绍</li><li>res是Nodejs本身的可写流，不做过多介绍</li><li>out是为了Connect的 <strong>sub app特性</strong> 而设计的参数，这个特性可以暂时忽略，这个参数我们暂时不关心</li></ol><p><strong>处理过程:</strong></p><p>可以回头看一下上面的<a href="#middlewares">requestHandler函数</a>，handle的实现是这个函数的增强版</p><ol><li>取得stack(存储<code>逻辑处理函数</code>列表)，index(列表下标)</li><li>构建next函数，next的作用是执行下一个<code>逻辑处理函数</code></li><li>触发第一个next，触发链式调用</li></ol><p><strong>next函数实现:</strong></p><p>next函数实现在handle函数体内，用来<code>顺序执行处理逻辑</code>，它是异步流程控制库的核心，不明白它的作用请看<a href="#next">上面的异步流程控制库简介</a></p><p>path是请求路径，route是<code>逻辑处理函数</code>自带的属性。</p><ol><li>取得下一个<code>逻辑处理函数</code>;</li><li>若路由不匹配，跳过此逻辑;</li><li>若路由匹配<a href="#call">下面的call</a>执行匹配到的<code>逻辑处理函数</code></li></ol><p>tips: 跟上一章最后的代码一样，每个<code>逻辑处理函数</code>调用<code>next</code>来让后面的函数执行，存储在stack中的函数就实现了<code>链式调用</code>。不一定所有的函数都在返回的时候才调用<code>next</code>，为了不影响效率，有的函数可能先调用next，然而自己还没有返回，继续做自己的事情。</p><p>核心代码：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">//取下一个逻辑逻辑处理函数</span>\n<span class="token number">1</span><span class="token operator">:</span>  <span class="token keyword">let</span> layer <span class="token operator">=</span> stack<span class="token punctuation">[</span>index<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token comment">//不匹配时跳过</span>\n<span class="token number">2</span><span class="token operator">:</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> route<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!==</span> route<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token function">next</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token comment">//匹配时执行</span>\n<span class="token number">3</span><span class="token operator">:</span>  <span class="token function">call</span><span class="token punctuation">(</span>layer<span class="token punctuation">.</span>handle<span class="token punctuation">,</span> route<span class="token punctuation">,</span> err<span class="token punctuation">,</span> req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>画图总结</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>request come\n     |\n     v\nmiddleware1 :  不匹配路由，skip\n     |\n     v\nmiddleware2 :  匹配路由，执行\n     |\n     v\nmiddleware3 :  匹配路由，执行\n     |\n     v\nmiddleware4 :  不匹配路由，skip\n     |\n     v\n    end\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a name="call"></a></p><h2 id="call-handle-route-err-req-res-next" tabindex="-1"><a class="header-anchor" href="#call-handle-route-err-req-res-next" aria-hidden="true">#</a> call(handle, route, err, req, res, next)</h2><blockquote><p>这里有个比较有趣的知识，<code>console.log(Function.length)</code>会返回函数定义的参数个数。</p></blockquote><p>Connect中规定<code>function(err, req, res, next) {}</code>形式为错误处理函数，<code>function(req, res, next) {}</code>为正常的业务逻辑处理函数。那么，可以根据Function.length以判断它是否为错误处理函数。</p><p><strong>输入:</strong></p><table><thead><tr><th>参数名</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td>handle</td><td style="text-align:center;">逻辑处理函数</td></tr><tr><td>route</td><td style="text-align:center;">路由</td></tr><tr><td>err</td><td style="text-align:center;">是否发生过错误</td></tr><tr><td>req</td><td style="text-align:center;">Nodejs对象</td></tr><tr><td>res</td><td style="text-align:center;">Nodejs对象</td></tr><tr><td>next</td><td style="text-align:center;">next函数</td></tr></tbody></table><p><strong>处理过程:</strong></p><ol><li>是否有错误，本次handle是否是错误处理函数;</li><li>若有错误且handle为错误处理函数，则执行handle，本函数返回;</li><li>若没错误且handle不是错误处理函数，则执行handle，本函数返回;</li><li>如果上面两个都不满足，不执行handle，本函数调用next，返回;</li></ol><p><strong>返回:</strong></p><p>无</p><p><strong>总结:</strong></p><p>call函数是一个执行者，根据当前<code>错误情况</code>和<code>handle类型</code>决定<code>是否执行</code>当前的handle。</p><h2 id="listen" tabindex="-1"><a class="header-anchor" href="#listen" aria-hidden="true">#</a> listen</h2><p>创建一个httpServer，将Connect自己的业务逻辑作为requestHandler，监听端口</p><p>代码</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">return</span> server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>server<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="图解connect" tabindex="-1"><a class="header-anchor" href="#图解connect" aria-hidden="true">#</a> 图解Connect</h2><p>Connect将中间件存储在app.stack中，通过构造handle中的next函数在请求到来时依次调用这些中间件。</p><p>图形总结</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>request               app(out)\n   |                          yes\n   +------------------&gt;match?-----&gt;middleware1\n                         | no          |\n                         v             |\n                        next&lt;----------+\n                         |\n                         v    yes\n                      match?------&gt;middleware2\n                         | no          |\n                         v             |\n                        next&lt;----------+\n                         |\n                         v    yes\n                      match?------&gt;middleware3\n                         | no          |\n                         v             |\n                        out&lt;-----------+\n                         |\n   +---------------------+\n   |\n   v\n  end(response在处理过程中已经返回了)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="connect的subapp特性" tabindex="-1"><a class="header-anchor" href="#connect的subapp特性" aria-hidden="true">#</a> Connect的subapp特性</h2><p>我们再看看Connect是怎么实现subapp的，比较有趣。</p><p>什么是subapp?</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let sub_app = connect();\nlet app = connect();\n\napp.use(&#39;/route1&#39;, sub_app);\n// request path: &#39;/route1/route2&#39;\n// 由app接收到请求后，切割 path为&#39;/route2&#39;转交给sub_app的处理逻辑处理\n// 再由sub_app返回到app，由app继续向下执行处理逻辑\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>结合上面的函数画图</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>request               app(out1)                 sub_app(out2)\n   |\n   +---------------&gt;middleware1     +------------&gt;middleware1\n                         |          |                 |\n                        next        |                next\n                         |          |                 |\n                         v          |                 v\n                    middleware2-----+            middleware2\n                                                      |\n                       next&lt;--------+                next\n                         |          |                 |\n                         v          |                 v\n                     middleware3    |            middleware3\n                         |          |                 |\n                         v          |                 v\n                        out1        |                out2\n                         |          |                 |\n   +---------------------+          +-----------------+\n   |\n   v\n  end(response在处理过程中已经返回了)\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>完成上面的sub_app只需要做到两点：</p><ol><li>从app的调用链进入到sub_app的调用链中;</li><li>从sub_app的逻辑回到app的调用链中;</li></ol><p>connect在handle函数中的第三个参数<code>out</code>为这个特性实现提供可能。<code>out</code>的特点是<code>在middlewares链式调用完成以后调用</code>。<strong>那么将app的next作为sub_app的out传入sub_app的handle中</strong>可以做到sub_app自己的业务逻辑处理完后调用<code>out</code>，即处理权回到了本app的<code>next</code>手里。</p><p>上面图中的<code>sub_app.out2===app.next</code>，所以能完成逻辑的交接和sub app调用。</p>',64),S={id:"express",tabindex:"-1"},R=(0,e._)("a",{class:"header-anchor",href:"#express","aria-hidden":"true"},"#",-1),H={href:"https://github.com/strongloop/express",target:"_blank",rel:"noopener noreferrer"},T=(0,e.uE)('<p>大家都知道Express是Connect的升级版。</p><p>Express不只是Connect的升级版，它还封装了很多对象来方便业务逻辑处理。Express里的Router是Connect的升级版。</p><p>Express大概可以分为几个模块</p><table><thead><tr><th>模块</th><th style="text-align:center;">描述</th></tr></thead><tbody><tr><td>router</td><td style="text-align:center;">路由模块是Connect升级版</td></tr><tr><td>request</td><td style="text-align:center;">经过Express封装的req对象</td></tr><tr><td>response</td><td style="text-align:center;">经过Express封装的res对象</td></tr><tr><td>application</td><td style="text-align:center;">app上面的各种默认设置</td></tr></tbody></table><p>简要介绍一下每个模块</p><h2 id="router" tabindex="-1"><a class="header-anchor" href="#router" aria-hidden="true">#</a> Router</h2><p>在Connect中间件特性的基础上，加入了如下特性，是Connect的升级版</p><ol><li>正则匹配route;</li><li>进行将http的方法在route中分解开;</li></ol><h2 id="request" tabindex="-1"><a class="header-anchor" href="#request" aria-hidden="true">#</a> Request</h2><p>在Request中集成了http.IncomingMessage(可读流+事件)，并在其上增加了新的属性，方便使用，我们最常用的应该是 req.param。</p><h2 id="response" tabindex="-1"><a class="header-anchor" href="#response" aria-hidden="true">#</a> Response</h2><p>在Response中集成了http.ServerResponse(可写流+事件)，并在其上增加了很多方便返回的函数，有我们熟悉的res.json、 res.render、res.redirect、res.sendFile等等。</p><p>我们可以拓展它写一个res.sendPersonInfoById。</p><blockquote><p>关于流的题外话：req.pipe(res)的形式可以“完成发什么就返回什么”，而req.pipe(mylogic).pipe(res)可以添加自己的逻辑， 我们的业务逻辑是把流读为String/Object再进行逻辑处理，处理完再推送给另一个stream，有没有可能在流的层面进行逻辑解 耦提供服务呢？求大神解答了…至少这种写法在大流量、逻辑简单的情况下是有用的。</p></blockquote><h2 id="application" tabindex="-1"><a class="header-anchor" href="#application" aria-hidden="true">#</a> Application</h2><p>除了上面的三个模块以外，还需要有个地方存储整个app的属性、设置等。比较常用的是app.engine函数设置模板引擎。</p><h2 id="express小结" tabindex="-1"><a class="header-anchor" href="#express小结" aria-hidden="true">#</a> Express小结</h2><p>Express是一个中间件机制的httpServer框架，它本身实现了中间件机制，它也包含了中间件。比如3.x版本的Express 本身自带bodyParser、cookieSession等中间件，而在4.x中去掉了。包括TJ也写了很多中间件，比如node-querystring、 connect-redis等。</p><p>实现业务逻辑解耦时，中间件是从纵向的方面进行的逻辑分解，前面的中间件处理的结果可以给后面用，比如bodyParser把解析 body的结果放在req.body中，后面的逻辑都可以从req.body中取值。由于中间件是顺序执行的，errHandler一般都放在最后，而log类的中间件则放在比较前面。</p><h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1>',20),P={href:"https://github.com/koajs/koa",target:"_blank",rel:"noopener noreferrer"},N=(0,e._)("p",null,"我们应该也可以用事件、Promise的方式实现；",-1),I=(0,e._)("p",null,"PS: 用事件来实现的话还挺期待的，能形成网状的相互调用。",-1),W={},D=(0,a(8580).Z)(W,[["render",function(n,s){const a=(0,e.up)("ExternalLinkIcon");return(0,e.wg)(),(0,e.iD)("div",null,[t,(0,e._)("ul",null,[(0,e._)("li",null,[(0,e._)("a",p,[(0,e.Uk)("EventProxy"),(0,e.Wm)(a)]),(0,e.Uk)(" —— 事件发布订阅模式(第四课讲到)")]),(0,e._)("li",null,[(0,e._)("a",o,[(0,e.Uk)("BlueBird"),(0,e.Wm)(a)]),(0,e.Uk)(" —— Promise方案(第十七课讲到)")]),(0,e._)("li",null,[(0,e._)("a",c,[(0,e.Uk)("Async"),(0,e.Wm)(a)]),(0,e.Uk)(" —— 异步流程控制库(第五课讲到)")]),(0,e._)("li",null,[(0,e._)("a",l,[(0,e.Uk)("Generator"),(0,e.Wm)(a)]),(0,e.Uk)(" —— ES6原生Generator")])]),i,(0,e._)("p",null,[r,(0,e.Uk)(" 关于异步流程控制库下面简要介绍下，或移步"),(0,e._)("a",u,[(0,e.Uk)("@第五课"),(0,e.Wm)(a)]),(0,e.Uk)("。 异步流程控制库首先要求用户传入待执行的函数列表，记为funlist。流程控制库的任务是让这些函数 "),d,(0,e.Uk)(" 。")]),k,v,m,b,(0,e._)("h1",h,[g,(0,e.Uk)(),(0,e._)("a",f,[(0,e.Uk)("Connect"),(0,e.Wm)(a)]),(0,e.Uk)("的实现")]),x,(0,e._)("ol",null,[y,(0,e._)("li",null,[(0,e.Uk)("app具有Event所有属性(详见"),(0,e._)("a",w,[(0,e.Uk)("utils-merge"),(0,e.Wm)(a)]),(0,e.Uk)("，十行代码)")]),_]),q,(0,e._)("ol",null,[j,(0,e._)("li",null,[(0,e.Uk)("一个"),(0,e._)("a",U,[(0,e.Uk)("httpServer"),(0,e.Wm)(a)]),(0,e.Uk)("；")]),C]),E,(0,e._)("h1",S,[R,(0,e.Uk)(),(0,e._)("a",H,[(0,e.Uk)("Express"),(0,e.Wm)(a)])]),T,(0,e._)("p",null,[(0,e.Uk)("Connect用流程控制库的回调函数及中间件的思想来解耦回调逻辑； "),(0,e._)("a",P,[(0,e.Uk)("Koa"),(0,e.Wm)(a)]),(0,e.Uk)("用Generator方法解决回调问题；")]),N,I])}]])},8580:(n,s)=>{s.Z=(n,s)=>{const a=n.__vccOpts||n;for(const[n,e]of s)a[n]=e;return a}}}]);