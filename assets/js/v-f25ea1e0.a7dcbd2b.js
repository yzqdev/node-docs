"use strict";(self.webpackChunknode_docs=self.webpackChunknode_docs||[]).push([[1709],{138:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a=JSON.parse('{"key":"v-f25ea1e0","path":"/nodejs/02_code_management_and_deployment.html","title":"代码的组织和部署","lang":"zh-CN","frontmatter":{"index":2,"description":"有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。 模块路径解析规则 我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间...","head":[["meta",{"property":"og:url","content":"https://yzqdev.github.io/node-docs/node-docs/nodejs/02_code_management_and_deployment.html"}],["meta",{"property":"og:site_name","content":"node-docs"}],["meta",{"property":"og:title","content":"代码的组织和部署"}],["meta",{"property":"og:description","content":"有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。 模块路径解析规则 我们已经知道，require函数支持斜杠（/）或盘符（C:）开头的绝对路径，也支持./开头的相对路径。但这两种路径在模块之间..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-03-26T15:48:25.000Z"}],["meta",{"property":"article:modified_time","content":"2022-03-26T15:48:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"代码的组织和部署\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-03-26T15:48:25.000Z\\",\\"author\\":[]}"]]},"headers":[{"level":2,"title":"模块路径解析规则","slug":"模块路径解析规则","link":"#模块路径解析规则","children":[]},{"level":2,"title":"包（package）","slug":"包-package","link":"#包-package","children":[{"level":3,"title":"index.js","slug":"index-js","link":"#index-js","children":[]},{"level":3,"title":"package.json","slug":"package-json","link":"#package-json","children":[]}]},{"level":2,"title":"命令行程序","slug":"命令行程序","link":"#命令行程序","children":[{"level":3,"title":"Linux","slug":"linux","link":"#linux","children":[]},{"level":3,"title":"Windows","slug":"windows","link":"#windows","children":[]}]},{"level":2,"title":"工程目录","slug":"工程目录","link":"#工程目录","children":[]},{"level":2,"title":"NPM","slug":"npm","link":"#npm","children":[{"level":3,"title":"下载三方包","slug":"下载三方包","link":"#下载三方包","children":[]},{"level":3,"title":"安装命令行程序","slug":"安装命令行程序","link":"#安装命令行程序","children":[]},{"level":3,"title":"发布代码","slug":"发布代码","link":"#发布代码","children":[]},{"level":3,"title":"版本号","slug":"版本号","link":"#版本号","children":[]},{"level":3,"title":"灵机一点","slug":"灵机一点","link":"#灵机一点","children":[]}]},{"level":2,"title":"小结","slug":"小结","link":"#小结","children":[]}],"git":{"createdTime":1648054750000,"updatedTime":1648309705000,"contributors":[{"name":"yzqdev","email":"yzqdev@outlook.com","commits":3}]},"readingTime":{"minutes":11.71,"words":3514},"filePathRelative":"nodejs/02_code_management_and_deployment.md","localizedDate":"2022年3月23日","autoDesc":true,"excerpt":""}')},8372:(n,e,s)=>{s.r(e),s.d(e,{default:()=>b});var a=s(6808);const o=(0,a.uE)('<h1 id="代码的组织和部署" tabindex="-1"><a class="header-anchor" href="#代码的组织和部署" aria-hidden="true">#</a> 代码的组织和部署</h1><hr><p>有经验的C程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJS编写程序前，为了有个良好的开端，首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。本章将介绍与之相关的各种知识。</p><h2 id="模块路径解析规则" tabindex="-1"><a class="header-anchor" href="#模块路径解析规则" aria-hidden="true">#</a> 模块路径解析规则</h2><p>我们已经知道，<code>require</code>函数支持斜杠（<code>/</code>）或盘符（<code>C:</code>）开头的绝对路径，也支持<code>./</code>开头的相对路径。但这两种路径在模块之间建立了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其它模块的代码也需要跟着调整，变得牵一发动全身。因此，<code>require</code>函数支持第三种形式的路径，写法类似于<code>foo/bar</code>，并依次按照以下规则解析路径，直到找到模块位置。</p><ol><li>内置模块</li></ol><p>如果传递给<code>require</code>函数的是NodeJS内置模块名称，不做路径解析，直接返回内部模块的导出对象，例如<code>require(&#39;fs&#39;)</code>。</p><ol start="2"><li>node_modules目录</li></ol><p>NodeJS定义了一个特殊的<code>node_modules</code>目录用于存放模块。例如某个模块的绝对路径是<code>/home/user/hello.js</code>，在该模块中使用<code>require(&#39;foo/bar&#39;)</code>方式加载模块时，则NodeJS依次尝试使用以下路径。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  /home/user/node_modules/foo/bar\n  /home/node_modules/foo/bar\n  /node_modules/foo/bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>NODE_PATH环境变量</li></ol><p>与PATH环境变量类似，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含一到多个目录路径，路径之间在Linux下使用<code>:</code>分隔，在Windows下使用<code>;</code>分隔。例如定义了以下NODE_PATH环境变量：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token assign-left variable">NODE_PATH</span><span class="token operator">=</span>/home/user/lib:/home/lib\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当使用<code>require(&#39;foo/bar&#39;)</code>的方式加载模块时，则NodeJS依次尝试以下路径。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>  /home/user/lib/foo/bar\n  /home/lib/foo/bar\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="包-package" tabindex="-1"><a class="header-anchor" href="#包-package" aria-hidden="true">#</a> 包（package）</h2><p>我们已经知道了JS模块的基本单位是单个JS文件，但复杂些的模块往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称做<code>包</code>，并把所有子模块放在同一个目录里。</p><p>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被作为包的导出对象。例如有以下目录结构。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- /home/user/lib/\n- cat/\n   head.js\n   body.js\n   main.js\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中<code>cat</code>目录定义了一个包，其中包含了3个子模块。<code>main.js</code>作为入口模块，其内容如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">let</span> head <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./head&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token keyword">let</span> body <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;./body&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n exports<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n   <span class="token literal-property property">name</span><span class="token operator">:</span> name<span class="token punctuation">,</span>\n   <span class="token literal-property property">head</span><span class="token operator">:</span> head<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n   <span class="token literal-property property">body</span><span class="token operator">:</span> body<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在其它模块里使用包的时候，需要加载包的入口模块。接着上例，使用<code>require(&#39;/home/user/lib/cat/main&#39;)</code>能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。</p><h3 id="index-js" tabindex="-1"><a class="header-anchor" href="#index-js" aria-hidden="true">#</a> index.js</h3><p>当模块的文件名是<code>index.js</code>，加载模块时可以使用模块所在目录的路径代替模块文件路径，因此接着上例，以下两条语句等价。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;/home/user/lib/cat&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n <span class="token keyword">let</span> cat <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;/home/user/lib/cat/index&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这样处理后，就只需要把包目录路径传递给<code>require</code>函数，感觉上整个目录被当作单个模块使用，更有整体感。</p><h3 id="package-json" tabindex="-1"><a class="header-anchor" href="#package-json" aria-hidden="true">#</a> package.json</h3><p>如果想自定义入口模块的文件名和存放位置，就需要在包目录下包含一个<code>package.json</code>文件，并在其中指定入口模块的路径。上例中的<code>cat</code>模块可以重构如下。</p><ul><li><p>/home/user/lib/</p></li><li><p>cat/</p></li><li><p>doc/</p></li><li><p>lib/ head.js body.js main.js</p></li><li><p>tests/ package.json</p></li></ul><p>其中<code>package.json</code>内容如下。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code> <span class="token punctuation">{</span>\n  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;cat&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/main.js&quot;</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此一来，就同样可以使用<code>require(&#39;/home/user/lib/cat&#39;)</code>的方式加载模块。NodeJS会根据包目录下的<code>package.json</code>找到入口模块所在位置。</p><h2 id="命令行程序" tabindex="-1"><a class="header-anchor" href="#命令行程序" aria-hidden="true">#</a> 命令行程序</h2><p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。</p><p>例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，我们把该程序部署在<code>/home/user/bin/node-echo.js</code>这个位置。为了在任何目录下都能运行该程序，我们需要使用以下终端命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> $ <span class="token function">node</span> /home/user/bin/node-echo.js Hello World\n Hello World\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这种使用方式看起来不怎么像是一个命令行程序，下边的才是我们期望的方式。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> node-echo Hello World\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="linux" tabindex="-1"><a class="header-anchor" href="#linux" aria-hidden="true">#</a> Linux</h3><p>在Linux系统下，我们可以把JS文件当作shell脚本来运行，从而达到上述目的，具体步骤如下：</p><ol><li>在shell脚本中，可以通过<code>#!</code>注释来指定当前脚本使用的解析器。所以我们首先在<code>node-echo.js</code>文件顶部增加以下一行注释，表明当前脚本使用NodeJS解析。</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token comment">#! /usr/bin/env node</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>NodeJS会忽略掉位于JS模块首行的<code>#!</code>注释，不必担心这行注释是非法语句。</p><ol start="2"><li>然后，我们使用以下命令赋予<code>node-echo.js</code>文件执行权限。</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token function">chmod</span> +x /home/user/bin/node-echo.js\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>最后，我们在PATH环境变量中指定的某个目录下，例如在<code>/usr/local/bin</code>下边创建一个软链文件，文件名与我们希望使用的终端命令同名，命令如下：</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>  <span class="token function">sudo</span> <span class="token function">ln</span> <span class="token parameter variable">-s</span> /home/user/bin/node-echo.js /usr/local/bin/node-echo\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p><h3 id="windows" tabindex="-1"><a class="header-anchor" href="#windows" aria-hidden="true">#</a> Windows</h3><p>在Windows系统下的做法完全不同，我们得靠<code>.cmd</code>文件来解决问题。假设<code>node-echo.js</code>存放在<code>C:\\Users\\user\\bin</code>目录，并且该目录已经添加到PATH环境变量里了。接下来需要在该目录下新建一个名为<code>node-echo.cmd</code>的文件，文件内容如下：</p><p>@node &quot;C:\\User\\user\\bin\\node-echo.js&quot; %*</p><p>这样处理后，我们就可以在任何目录下使用<code>node-echo</code>命令了。</p><h2 id="工程目录" tabindex="-1"><a class="header-anchor" href="#工程目录" aria-hidden="true">#</a> 工程目录</h2><p>了解了以上知识后，现在我们可以来完整地规划一个工程目录了。以编写一个命令行程序为例，一般我们会同时提供命令行模式和API模式两种使用方式，并且我们会借助三方包来编写代码。除了代码外，一个完整的程序也应该有自己的文档和测试用例。因此，一个标准的工程目录都看起来像下边这样。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- /home/user/workspace/node-echo/   # 工程目录\n- bin/                          # 存放命令行相关代码\n   node-echo\n\n- doc/                          # 存放文档\n\n- lib/                          # 存放API相关代码\n   echo.js\n- node_modules/                 # 存放三方包\n\n- argv/\n- tests/                        # 存放测试用例\n  package.json                    # 元数据文件\n  README.md                       # 说明文件\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中部分文件内容如下：</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code> <span class="token comment">/*bin/node-echo*/</span>\n <span class="token keyword">let</span> argv <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;argv&#39;</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  echo <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;../lib/echo&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">echo</span><span class="token punctuation">(</span>argv<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&#39; &#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n <span class="token comment">/*lib/echo.js*/</span>\n module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> message<span class="token punctuation">;</span>\n <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n <span class="token comment">/*package.json*/</span>\n <span class="token punctuation">{</span>\n  <span class="token string-property property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node-echo&quot;</span><span class="token punctuation">,</span>\n  <span class="token string-property property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/echo.js&quot;</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上例子中分类存放了不同类型的文件，并通过<code>node_moudles</code>目录直接使用三方包名加载模块。此外，定义了<code>package.json</code>之后，<code>node-echo</code>目录也可被当作一个包来使用。</p><h2 id="npm" tabindex="-1"><a class="header-anchor" href="#npm" aria-hidden="true">#</a> NPM</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p><ul><li><p>允许用户从NPM服务器下载别人编写的三方包到本地使用。</p></li><li><p>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</p></li><li><p>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</p></li></ul><p>可以看到，NPM建立了一个NodeJS生态圈，NodeJS开发者和用户可以在里边互通有无。以下分别介绍这三种场景下怎样使用NPM。</p><h3 id="下载三方包" tabindex="-1"><a class="header-anchor" href="#下载三方包" aria-hidden="true">#</a> 下载三方包</h3>',63),i={href:"https://npmjs.org/",target:"_blank",rel:"noopener noreferrer"},l=(0,a._)("code",null,"argv",-1),d=(0,a.uE)('<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> $ <span class="token function">npm</span> <span class="token function">install</span> argv\n <span class="token punctuation">..</span>.\n argv@0.0.2 node_modules<span class="token punctuation">\\</span>argv\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下载好之后，<code>argv</code>包就放在了工程目录下的<code>node_modules</code>目录中，因此在代码中只需要通过<code>require(&#39;argv&#39;)</code>的方式就好，无需指定三方包路径。</p><p>以上命令默认下载最新版三方包，如果想要下载指定版本的话，可以在包名后边加上<code>@&lt;version&gt;</code>，例如通过以下命令可下载0.0.1版的<code>argv</code>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> $ <span class="token function">npm</span> <span class="token function">install</span> argv@0.0.1\n <span class="token punctuation">..</span>.\n argv@0.0.1 node_modules<span class="token punctuation">\\</span>argv\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果使用到的三方包比较多，在终端下一个包一条命令地安装未免太人肉了。因此NPM对<code>package.json</code>的字段做了扩展，允许在其中申明三方包依赖。因此，上边例子中的<code>package.json</code>可以改写如下：</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code> <span class="token punctuation">{</span>\n  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node-echo&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/echo.js&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n   <span class="token property">&quot;argv&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.0.2&quot;</span>\n  <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样处理后，在工程目录下就可以使用<code>npm install</code>命令批量安装三方包了。更重要的是，当以后<code>node-echo</code>也上传到了NPM服务器，别人下载这个包时，NPM会根据包中申明的三方包依赖自动下载进一步依赖的三方包。例如，使用<code>npm install node-echo</code>命令时，NPM会自动创建以下目录结构。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- project/\n- node_modules/\n- node-echo/\n  - node_modules/\n  - argv/\n    ...\n  ...\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如此一来，用户只需关心自己直接使用的三方包，不需要自己去解决所有包的依赖关系。</p><h3 id="安装命令行程序" tabindex="-1"><a class="header-anchor" href="#安装命令行程序" aria-hidden="true">#</a> 安装命令行程序</h3><p>从NPM服务上下载安装一个命令行程序的方法与三方包类似。例如上例中的<code>node-echo</code>提供了命令行使用方式，只要<code>node-echo</code>自己配置好了相关的<code>package.json</code>字段，对于用户而言，只需要使用以下命令安装程序。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code> <span class="token function">npm</span> <span class="token function">install</span> node-echo <span class="token parameter variable">-g</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数中的<code>-g</code>表示全局安装，因此<code>node-echo</code>会默认安装到以下位置，并且NPM会自动创建好Linux系统下需要的软链文件或Windows系统下需要的<code>.cmd</code>文件。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>- /usr/local/               # Linux系统下\n- lib/node_modules/\n\n- node-echo/\n   ...\n\n- bin/\n   node-echo\n   ...\n  ...\n\n- %APPDATA%\\npm\\            # Windows系统下\n- node_modules\\\n\n- node-echo\\\n   ...\n  node-echo.cmd\n  ...\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="发布代码" tabindex="-1"><a class="header-anchor" href="#发布代码" aria-hidden="true">#</a> 发布代码</h3><p>第一次使用NPM发布代码前需要注册一个账号。终端下运行<code>npm adduser</code>，之后按照提示做即可。账号搞定后，接着我们需要编辑<code>package.json</code>文件，加入NPM必需的字段。接着上边<code>node-echo</code>的例子，<code>package.json</code>里必要的字段如下。</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code> <span class="token punctuation">{</span>\n  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node-echo&quot;</span><span class="token punctuation">,</span>           # 包名，在NPM服务器上须要保持唯一\n  <span class="token property">&quot;version&quot;</span><span class="token operator">:</span> <span class="token string">&quot;1.0.0&quot;</span><span class="token punctuation">,</span>            # 当前版本号\n  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>              # 三方包依赖，需要指定包名和版本号\n   <span class="token property">&quot;argv&quot;</span><span class="token operator">:</span> <span class="token string">&quot;0.0.2&quot;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./lib/echo.js&quot;</span><span class="token punctuation">,</span>       # 入口模块位置\n  <span class="token property">&quot;bin&quot;</span> <span class="token operator">:</span> <span class="token punctuation">{</span>\n   <span class="token property">&quot;node-echo&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./bin/node-echo&quot;</span>      # 命令行程序名和主模块位置\n  <span class="token punctuation">}</span>\n <span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>之后，我们就可以在<code>package.json</code>所在目录下运行<code>npm publish</code>发布代码了。</p><h3 id="版本号" tabindex="-1"><a class="header-anchor" href="#版本号" aria-hidden="true">#</a> 版本号</h3><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。</p><p>语义版本号分为<code>X.Y.Z</code>三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p><ul><li><p>如果只是修复bug，需要更新Z位。</p></li><li><p>如果是新增了功能，但是向下兼容，需要更新Y位。</p></li><li><p>如果有大变动，向下不兼容，需要更新X位。</p></li></ul>',22),c=(0,a._)("code",null,'"argv": "0.0.x"',-1),t=(0,a._)("code",null,"0.0.x",-1),p=(0,a._)("code",null,"argv",-1),r={href:"https://npmjs.org/doc/files/package.json.html#dependencies",target:"_blank",rel:"noopener noreferrer"},u=(0,a._)("h3",{id:"灵机一点",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#灵机一点","aria-hidden":"true"},"#"),(0,a.Uk)(" 灵机一点")],-1),v=(0,a._)("code",null,"package.json",-1),m={href:"https://npmjs.org/doc/",target:"_blank",rel:"noopener noreferrer"},k=(0,a.uE)('<ul><li><p>NPM提供了很多命令，例如<code>install</code>和<code>publish</code>，使用<code>npm help</code>可查看所有命令。</p></li><li><p>使用<code>npm help &lt;command&gt;</code>可查看某条命令的详细帮助，例如<code>npm help install</code>。</p></li><li><p>在<code>package.json</code>所在目录下使用<code>npm install . -g</code>可先在本地安装当前命令行程序，可用于发布前的本地测试。</p></li><li><p>使用<code>npm update &lt;package&gt;</code>可以把当前目录下<code>node_modules</code>子目录里边的对应模块更新至最新版本。</p></li><li><p>使用<code>npm update &lt;package&gt; -g</code>可以把全局安装的对应命令行程序更新至最新版。</p></li><li><p>使用<code>npm cache clear</code>可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</p></li><li><p>使用<code>npm unpublish &lt;package&gt;@&lt;version&gt;</code>可以撤销发布自己发布过的某个版本代码。</p></li></ul><h2 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h2><p>本章介绍了使用NodeJS编写代码前需要做的准备工作，总结起来有以下几点：</p><ul><li><p>编写代码前先规划好目录结构，才能做到有条不紊。</p></li><li><p>稍大些的程序可以将代码拆分为多个模块管理，更大些的程序可以使用包来组织模块。</p></li><li><p>合理使用<code>node_modules</code>和<code>NODE_PATH</code>来解耦包的使用方式和物理路径。</p></li><li><p>使用NPM加入NodeJS生态圈互通有无。</p></li><li><p>想到了心仪的包名时请提前在NPM上抢注。</p></li></ul>',4),h={},b=(0,s(8580).Z)(h,[["render",function(n,e){const s=(0,a.up)("ExternalLinkIcon");return(0,a.wg)(),(0,a.iD)("div",null,[o,(0,a._)("p",null,[(0,a.Uk)("需要使用三方包时，首先得知道有哪些包可用。虽然"),(0,a._)("a",i,[(0,a.Uk)("npmjs.org"),(0,a.Wm)(s)]),(0,a.Uk)("提供了个搜索框可以根据包名来搜索，但如果连想使用的三方包的名字都不确定的话，就请百度一下吧。知道了包名后，比如上边例子中的"),l,(0,a.Uk)("，就可以在工程目录下打开终端，使用以下命令来下载三方包。")]),d,(0,a._)("p",null,[(0,a.Uk)("版本号有了这个保证后，在申明三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如"),c,(0,a.Uk)("表示依赖于"),t,(0,a.Uk)("系列的最新版"),p,(0,a.Uk)("。NPM支持的所有版本号范围指定方式可以查看"),(0,a._)("a",r,[(0,a.Uk)("官方文档"),(0,a.Wm)(s)]),(0,a.Uk)("。")]),u,(0,a._)("p",null,[(0,a.Uk)("除了本章介绍的部分外，NPM还提供了很多功能，"),v,(0,a.Uk)("里也有很多其它有用的字段。除了可以在"),(0,a._)("a",m,[(0,a.Uk)("npmjs.org/doc/"),(0,a.Wm)(s)]),(0,a.Uk)("查看官方文档外，这里再介绍一些NPM常用命令。")]),k])}]])},8580:(n,e)=>{e.Z=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}}}]);